// Code generated by Microsoft (R) AutoRest Code Generator (autorest: 3.10.3, generator: @autorest/go@4.0.0-preview.69)
// Changes may cause incorrect behavior and will be lost if the code is regenerated.
// Code generated by @autorest/go. DO NOT EDIT.

package imds_generated

import (
	"encoding/json"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"reflect"
)

// MarshalJSON implements the json.Marshaller interface for type AttestedData.
func (a AttestedData) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "encoding", a.Encoding)
	populate(objectMap, "signature", a.Signature)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AttestedData.
func (a *AttestedData) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "encoding":
				err = unpopulate(val, "Encoding", &a.Encoding)
			delete(rawMsg, key)
		case "signature":
				err = unpopulate(val, "Signature", &a.Signature)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Compute.
func (c Compute) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "additionalCapabilities", c.AdditionalCapabilities)
	populate(objectMap, "azEnvironment", c.AzEnvironment)
	populate(objectMap, "evictionPolicy", c.EvictionPolicy)
	populate(objectMap, "extendedLocation", c.ExtendedLocation)
	populate(objectMap, "host", c.Host)
	populate(objectMap, "hostGroup", c.HostGroup)
	populate(objectMap, "isHostCompatibilityLayerVm", c.IsHostCompatibilityLayerVM)
	populate(objectMap, "licenseType", c.LicenseType)
	populate(objectMap, "location", c.Location)
	populate(objectMap, "name", c.Name)
	populate(objectMap, "osProfile", c.OSProfile)
	populate(objectMap, "osType", c.OSType)
	populate(objectMap, "offer", c.Offer)
	populate(objectMap, "placementGroupId", c.PlacementGroupID)
	populate(objectMap, "plan", c.Plan)
	populate(objectMap, "platformFaultDomain", c.PlatformFaultDomain)
	populate(objectMap, "platformSubFaultDomain", c.PlatformSubFaultDomain)
	populate(objectMap, "platformUpdateDomain", c.PlatformUpdateDomain)
	populate(objectMap, "priority", c.Priority)
	populate(objectMap, "provider", c.Provider)
	populate(objectMap, "publicKeys", c.PublicKeys)
	populate(objectMap, "publisher", c.Publisher)
	populate(objectMap, "resourceGroupName", c.ResourceGroupName)
	populate(objectMap, "resourceId", c.ResourceID)
	populate(objectMap, "sku", c.SKU)
	populate(objectMap, "securityProfile", c.SecurityProfile)
	populate(objectMap, "storageProfile", c.StorageProfile)
	populate(objectMap, "subscriptionId", c.SubscriptionID)
	populate(objectMap, "tags", c.Tags)
	populate(objectMap, "tagsList", c.TagsList)
	populate(objectMap, "userData", c.UserData)
	populate(objectMap, "vmId", c.VMID)
	populate(objectMap, "vmScaleSetName", c.VMScaleSetName)
	populate(objectMap, "vmSize", c.VMSize)
	populate(objectMap, "version", c.Version)
	populate(objectMap, "virtualMachineScaleSet", c.VirtualMachineScaleSet)
	populate(objectMap, "zone", c.Zone)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Compute.
func (c *Compute) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalCapabilities":
				err = unpopulate(val, "AdditionalCapabilities", &c.AdditionalCapabilities)
			delete(rawMsg, key)
		case "azEnvironment":
				err = unpopulate(val, "AzEnvironment", &c.AzEnvironment)
			delete(rawMsg, key)
		case "evictionPolicy":
				err = unpopulate(val, "EvictionPolicy", &c.EvictionPolicy)
			delete(rawMsg, key)
		case "extendedLocation":
				err = unpopulate(val, "ExtendedLocation", &c.ExtendedLocation)
			delete(rawMsg, key)
		case "host":
				err = unpopulate(val, "Host", &c.Host)
			delete(rawMsg, key)
		case "hostGroup":
				err = unpopulate(val, "HostGroup", &c.HostGroup)
			delete(rawMsg, key)
		case "isHostCompatibilityLayerVm":
				err = unpopulate(val, "IsHostCompatibilityLayerVM", &c.IsHostCompatibilityLayerVM)
			delete(rawMsg, key)
		case "licenseType":
				err = unpopulate(val, "LicenseType", &c.LicenseType)
			delete(rawMsg, key)
		case "location":
				err = unpopulate(val, "Location", &c.Location)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &c.Name)
			delete(rawMsg, key)
		case "osProfile":
				err = unpopulate(val, "OSProfile", &c.OSProfile)
			delete(rawMsg, key)
		case "osType":
				err = unpopulate(val, "OSType", &c.OSType)
			delete(rawMsg, key)
		case "offer":
				err = unpopulate(val, "Offer", &c.Offer)
			delete(rawMsg, key)
		case "placementGroupId":
				err = unpopulate(val, "PlacementGroupID", &c.PlacementGroupID)
			delete(rawMsg, key)
		case "plan":
				err = unpopulate(val, "Plan", &c.Plan)
			delete(rawMsg, key)
		case "platformFaultDomain":
				err = unpopulate(val, "PlatformFaultDomain", &c.PlatformFaultDomain)
			delete(rawMsg, key)
		case "platformSubFaultDomain":
				err = unpopulate(val, "PlatformSubFaultDomain", &c.PlatformSubFaultDomain)
			delete(rawMsg, key)
		case "platformUpdateDomain":
				err = unpopulate(val, "PlatformUpdateDomain", &c.PlatformUpdateDomain)
			delete(rawMsg, key)
		case "priority":
				err = unpopulate(val, "Priority", &c.Priority)
			delete(rawMsg, key)
		case "provider":
				err = unpopulate(val, "Provider", &c.Provider)
			delete(rawMsg, key)
		case "publicKeys":
				err = unpopulate(val, "PublicKeys", &c.PublicKeys)
			delete(rawMsg, key)
		case "publisher":
				err = unpopulate(val, "Publisher", &c.Publisher)
			delete(rawMsg, key)
		case "resourceGroupName":
				err = unpopulate(val, "ResourceGroupName", &c.ResourceGroupName)
			delete(rawMsg, key)
		case "resourceId":
				err = unpopulate(val, "ResourceID", &c.ResourceID)
			delete(rawMsg, key)
		case "sku":
				err = unpopulate(val, "SKU", &c.SKU)
			delete(rawMsg, key)
		case "securityProfile":
				err = unpopulate(val, "SecurityProfile", &c.SecurityProfile)
			delete(rawMsg, key)
		case "storageProfile":
				err = unpopulate(val, "StorageProfile", &c.StorageProfile)
			delete(rawMsg, key)
		case "subscriptionId":
				err = unpopulate(val, "SubscriptionID", &c.SubscriptionID)
			delete(rawMsg, key)
		case "tags":
				err = unpopulate(val, "Tags", &c.Tags)
			delete(rawMsg, key)
		case "tagsList":
				err = unpopulate(val, "TagsList", &c.TagsList)
			delete(rawMsg, key)
		case "userData":
				err = unpopulate(val, "UserData", &c.UserData)
			delete(rawMsg, key)
		case "vmId":
				err = unpopulate(val, "VMID", &c.VMID)
			delete(rawMsg, key)
		case "vmScaleSetName":
				err = unpopulate(val, "VMScaleSetName", &c.VMScaleSetName)
			delete(rawMsg, key)
		case "vmSize":
				err = unpopulate(val, "VMSize", &c.VMSize)
			delete(rawMsg, key)
		case "version":
				err = unpopulate(val, "Version", &c.Version)
			delete(rawMsg, key)
		case "virtualMachineScaleSet":
				err = unpopulate(val, "VirtualMachineScaleSet", &c.VirtualMachineScaleSet)
			delete(rawMsg, key)
		case "zone":
				err = unpopulate(val, "Zone", &c.Zone)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ComputeAdditionalCapabilities.
func (c ComputeAdditionalCapabilities) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "hibernationEnabled", c.HibernationEnabled)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ComputeAdditionalCapabilities.
func (c *ComputeAdditionalCapabilities) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "hibernationEnabled":
				err = unpopulate(val, "HibernationEnabled", &c.HibernationEnabled)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DataDisk.
func (d DataDisk) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "bytesPerSecondThrottle", d.BytesPerSecondThrottle)
	populate(objectMap, "caching", d.Caching)
	populate(objectMap, "createOption", d.CreateOption)
	populate(objectMap, "diskCapacityBytes", d.DiskCapacityBytes)
	populate(objectMap, "diskSizeGB", d.DiskSizeGB)
	populate(objectMap, "image", d.Image)
	populate(objectMap, "isSharedDisk", d.IsSharedDisk)
	populate(objectMap, "isUltraDisk", d.IsUltraDisk)
	populate(objectMap, "lun", d.Lun)
	populate(objectMap, "managedDisk", d.ManagedDisk)
	populate(objectMap, "name", d.Name)
	populate(objectMap, "opsPerSecondThrottle", d.OpsPerSecondThrottle)
	populate(objectMap, "vhd", d.Vhd)
	populate(objectMap, "writeAcceleratorEnabled", d.WriteAcceleratorEnabled)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataDisk.
func (d *DataDisk) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "bytesPerSecondThrottle":
				err = unpopulate(val, "BytesPerSecondThrottle", &d.BytesPerSecondThrottle)
			delete(rawMsg, key)
		case "caching":
				err = unpopulate(val, "Caching", &d.Caching)
			delete(rawMsg, key)
		case "createOption":
				err = unpopulate(val, "CreateOption", &d.CreateOption)
			delete(rawMsg, key)
		case "diskCapacityBytes":
				err = unpopulate(val, "DiskCapacityBytes", &d.DiskCapacityBytes)
			delete(rawMsg, key)
		case "diskSizeGB":
				err = unpopulate(val, "DiskSizeGB", &d.DiskSizeGB)
			delete(rawMsg, key)
		case "image":
				err = unpopulate(val, "Image", &d.Image)
			delete(rawMsg, key)
		case "isSharedDisk":
				err = unpopulate(val, "IsSharedDisk", &d.IsSharedDisk)
			delete(rawMsg, key)
		case "isUltraDisk":
				err = unpopulate(val, "IsUltraDisk", &d.IsUltraDisk)
			delete(rawMsg, key)
		case "lun":
				err = unpopulate(val, "Lun", &d.Lun)
			delete(rawMsg, key)
		case "managedDisk":
				err = unpopulate(val, "ManagedDisk", &d.ManagedDisk)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &d.Name)
			delete(rawMsg, key)
		case "opsPerSecondThrottle":
				err = unpopulate(val, "OpsPerSecondThrottle", &d.OpsPerSecondThrottle)
			delete(rawMsg, key)
		case "vhd":
				err = unpopulate(val, "Vhd", &d.Vhd)
			delete(rawMsg, key)
		case "writeAcceleratorEnabled":
				err = unpopulate(val, "WriteAcceleratorEnabled", &d.WriteAcceleratorEnabled)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DiffDiskSettings.
func (d DiffDiskSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "option", d.Option)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DiffDiskSettings.
func (d *DiffDiskSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "option":
				err = unpopulate(val, "Option", &d.Option)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DiskImage.
func (d DiskImage) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "uri", d.URI)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DiskImage.
func (d *DiskImage) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "uri":
				err = unpopulate(val, "URI", &d.URI)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EncryptionSettings.
func (e EncryptionSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "diskEncryptionKey", e.DiskEncryptionKey)
	populate(objectMap, "enabled", e.Enabled)
	populate(objectMap, "keyEncryptionKey", e.KeyEncryptionKey)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EncryptionSettings.
func (e *EncryptionSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "diskEncryptionKey":
				err = unpopulate(val, "DiskEncryptionKey", &e.DiskEncryptionKey)
			delete(rawMsg, key)
		case "enabled":
				err = unpopulate(val, "Enabled", &e.Enabled)
			delete(rawMsg, key)
		case "keyEncryptionKey":
				err = unpopulate(val, "KeyEncryptionKey", &e.KeyEncryptionKey)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EncryptionSettingsDiskEncryptionKey.
func (e EncryptionSettingsDiskEncryptionKey) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "secretUrl", e.SecretURL)
	populate(objectMap, "sourceVault", e.SourceVault)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EncryptionSettingsDiskEncryptionKey.
func (e *EncryptionSettingsDiskEncryptionKey) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "secretUrl":
				err = unpopulate(val, "SecretURL", &e.SecretURL)
			delete(rawMsg, key)
		case "sourceVault":
				err = unpopulate(val, "SourceVault", &e.SourceVault)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EncryptionSettingsDiskEncryptionKeySourceVault.
func (e EncryptionSettingsDiskEncryptionKeySourceVault) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", e.ID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EncryptionSettingsDiskEncryptionKeySourceVault.
func (e *EncryptionSettingsDiskEncryptionKeySourceVault) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
				err = unpopulate(val, "ID", &e.ID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EncryptionSettingsKeyEncryptionKey.
func (e EncryptionSettingsKeyEncryptionKey) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "keyUrl", e.KeyURL)
	populate(objectMap, "sourceVault", e.SourceVault)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EncryptionSettingsKeyEncryptionKey.
func (e *EncryptionSettingsKeyEncryptionKey) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "keyUrl":
				err = unpopulate(val, "KeyURL", &e.KeyURL)
			delete(rawMsg, key)
		case "sourceVault":
				err = unpopulate(val, "SourceVault", &e.SourceVault)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EncryptionSettingsKeyEncryptionKeySourceVault.
func (e EncryptionSettingsKeyEncryptionKeySourceVault) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", e.ID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EncryptionSettingsKeyEncryptionKeySourceVault.
func (e *EncryptionSettingsKeyEncryptionKeySourceVault) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
				err = unpopulate(val, "ID", &e.ID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ErrorResponse.
func (e ErrorResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "error", e.Error)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ErrorResponse.
func (e *ErrorResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "error":
				err = unpopulate(val, "Error", &e.Error)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ExtendedLocationProperties.
func (e ExtendedLocationProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "name", e.Name)
	populate(objectMap, "type", e.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExtendedLocationProperties.
func (e *ExtendedLocationProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
				err = unpopulate(val, "Name", &e.Name)
			delete(rawMsg, key)
		case "type":
				err = unpopulate(val, "Type", &e.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Host.
func (h Host) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", h.ID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Host.
func (h *Host) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
				err = unpopulate(val, "ID", &h.ID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HostGroup.
func (h HostGroup) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", h.ID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HostGroup.
func (h *HostGroup) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
				err = unpopulate(val, "ID", &h.ID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IPv4Properties.
func (i IPv4Properties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "privateIpAddress", i.PrivateIPAddress)
	populate(objectMap, "publicIpAddress", i.PublicIPAddress)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IPv4Properties.
func (i *IPv4Properties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "privateIpAddress":
				err = unpopulate(val, "PrivateIPAddress", &i.PrivateIPAddress)
			delete(rawMsg, key)
		case "publicIpAddress":
				err = unpopulate(val, "PublicIPAddress", &i.PublicIPAddress)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IPv6Properties.
func (i IPv6Properties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "privateIpAddress", i.PrivateIPAddress)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IPv6Properties.
func (i *IPv6Properties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "privateIpAddress":
				err = unpopulate(val, "PrivateIPAddress", &i.PrivateIPAddress)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IdentityErrorResponse.
func (i IdentityErrorResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "error", i.Error)
	populate(objectMap, "error_description", i.ErrorDescription)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IdentityErrorResponse.
func (i *IdentityErrorResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "error":
				err = unpopulate(val, "Error", &i.Error)
			delete(rawMsg, key)
		case "error_description":
				err = unpopulate(val, "ErrorDescription", &i.ErrorDescription)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IdentityInfoResponse.
func (i IdentityInfoResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "tenantId", i.TenantID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IdentityInfoResponse.
func (i *IdentityInfoResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "tenantId":
				err = unpopulate(val, "TenantID", &i.TenantID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IdentityTokenResponse.
func (i IdentityTokenResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "access_token", i.AccessToken)
	populate(objectMap, "client_id", i.ClientID)
	populate(objectMap, "expires_in", i.ExpiresIn)
	populate(objectMap, "expires_on", i.ExpiresOn)
	populate(objectMap, "ext_expires_in", i.ExtExpiresIn)
	populate(objectMap, "msi_res_id", i.MsiResID)
	populate(objectMap, "not_before", i.NotBefore)
	populate(objectMap, "object_id", i.ObjectID)
	populate(objectMap, "resource", i.Resource)
	populate(objectMap, "token_type", i.TokenType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IdentityTokenResponse.
func (i *IdentityTokenResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "access_token":
				err = unpopulate(val, "AccessToken", &i.AccessToken)
			delete(rawMsg, key)
		case "client_id":
				err = unpopulate(val, "ClientID", &i.ClientID)
			delete(rawMsg, key)
		case "expires_in":
				err = unpopulate(val, "ExpiresIn", &i.ExpiresIn)
			delete(rawMsg, key)
		case "expires_on":
				err = unpopulate(val, "ExpiresOn", &i.ExpiresOn)
			delete(rawMsg, key)
		case "ext_expires_in":
				err = unpopulate(val, "ExtExpiresIn", &i.ExtExpiresIn)
			delete(rawMsg, key)
		case "msi_res_id":
				err = unpopulate(val, "MsiResID", &i.MsiResID)
			delete(rawMsg, key)
		case "not_before":
				err = unpopulate(val, "NotBefore", &i.NotBefore)
			delete(rawMsg, key)
		case "object_id":
				err = unpopulate(val, "ObjectID", &i.ObjectID)
			delete(rawMsg, key)
		case "resource":
				err = unpopulate(val, "Resource", &i.Resource)
			delete(rawMsg, key)
		case "token_type":
				err = unpopulate(val, "TokenType", &i.TokenType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ImageReference.
func (i ImageReference) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "communityGalleryImageId", i.CommunityGalleryImageID)
	populate(objectMap, "exactVersion", i.ExactVersion)
	populate(objectMap, "id", i.ID)
	populate(objectMap, "offer", i.Offer)
	populate(objectMap, "publisher", i.Publisher)
	populate(objectMap, "sku", i.SKU)
	populate(objectMap, "sharedGalleryImageId", i.SharedGalleryImageID)
	populate(objectMap, "version", i.Version)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ImageReference.
func (i *ImageReference) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "communityGalleryImageId":
				err = unpopulate(val, "CommunityGalleryImageID", &i.CommunityGalleryImageID)
			delete(rawMsg, key)
		case "exactVersion":
				err = unpopulate(val, "ExactVersion", &i.ExactVersion)
			delete(rawMsg, key)
		case "id":
				err = unpopulate(val, "ID", &i.ID)
			delete(rawMsg, key)
		case "offer":
				err = unpopulate(val, "Offer", &i.Offer)
			delete(rawMsg, key)
		case "publisher":
				err = unpopulate(val, "Publisher", &i.Publisher)
			delete(rawMsg, key)
		case "sku":
				err = unpopulate(val, "SKU", &i.SKU)
			delete(rawMsg, key)
		case "sharedGalleryImageId":
				err = unpopulate(val, "SharedGalleryImageID", &i.SharedGalleryImageID)
			delete(rawMsg, key)
		case "version":
				err = unpopulate(val, "Version", &i.Version)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Instance.
func (i Instance) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "compute", i.Compute)
	populate(objectMap, "network", i.Network)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Instance.
func (i *Instance) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "compute":
				err = unpopulate(val, "Compute", &i.Compute)
			delete(rawMsg, key)
		case "network":
				err = unpopulate(val, "Network", &i.Network)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ManagedDisk.
func (m ManagedDisk) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", m.ID)
	populate(objectMap, "storageAccountType", m.StorageAccountType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ManagedDisk.
func (m *ManagedDisk) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
				err = unpopulate(val, "ID", &m.ID)
			delete(rawMsg, key)
		case "storageAccountType":
				err = unpopulate(val, "StorageAccountType", &m.StorageAccountType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Network.
func (n Network) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "interface", n.Interface)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Network.
func (n *Network) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "interface":
				err = unpopulate(val, "Interface", &n.Interface)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NetworkInterface.
func (n NetworkInterface) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "ipv4", n.IPv4)
	populate(objectMap, "ipv6", n.IPv6)
	populate(objectMap, "macAddress", n.MacAddress)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NetworkInterface.
func (n *NetworkInterface) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "ipv4":
				err = unpopulate(val, "IPv4", &n.IPv4)
			delete(rawMsg, key)
		case "ipv6":
				err = unpopulate(val, "IPv6", &n.IPv6)
			delete(rawMsg, key)
		case "macAddress":
				err = unpopulate(val, "MacAddress", &n.MacAddress)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NetworkInterfaceIPv4.
func (n NetworkInterfaceIPv4) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "ipAddress", n.IPAddress)
	populate(objectMap, "subnet", n.Subnet)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NetworkInterfaceIPv4.
func (n *NetworkInterfaceIPv4) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "ipAddress":
				err = unpopulate(val, "IPAddress", &n.IPAddress)
			delete(rawMsg, key)
		case "subnet":
				err = unpopulate(val, "Subnet", &n.Subnet)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NetworkInterfaceIPv6.
func (n NetworkInterfaceIPv6) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "ipAddress", n.IPAddress)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NetworkInterfaceIPv6.
func (n *NetworkInterfaceIPv6) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "ipAddress":
				err = unpopulate(val, "IPAddress", &n.IPAddress)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OsDisk.
func (o OsDisk) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "caching", o.Caching)
	populate(objectMap, "createOption", o.CreateOption)
	populate(objectMap, "diffDiskSettings", o.DiffDiskSettings)
	populate(objectMap, "diskSizeGB", o.DiskSizeGB)
	populate(objectMap, "encryptionSettings", o.EncryptionSettings)
	populate(objectMap, "image", o.Image)
	populate(objectMap, "managedDisk", o.ManagedDisk)
	populate(objectMap, "name", o.Name)
	populate(objectMap, "osType", o.OSType)
	populate(objectMap, "vhd", o.Vhd)
	populate(objectMap, "writeAcceleratorEnabled", o.WriteAcceleratorEnabled)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OsDisk.
func (o *OsDisk) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "caching":
				err = unpopulate(val, "Caching", &o.Caching)
			delete(rawMsg, key)
		case "createOption":
				err = unpopulate(val, "CreateOption", &o.CreateOption)
			delete(rawMsg, key)
		case "diffDiskSettings":
				err = unpopulate(val, "DiffDiskSettings", &o.DiffDiskSettings)
			delete(rawMsg, key)
		case "diskSizeGB":
				err = unpopulate(val, "DiskSizeGB", &o.DiskSizeGB)
			delete(rawMsg, key)
		case "encryptionSettings":
				err = unpopulate(val, "EncryptionSettings", &o.EncryptionSettings)
			delete(rawMsg, key)
		case "image":
				err = unpopulate(val, "Image", &o.Image)
			delete(rawMsg, key)
		case "managedDisk":
				err = unpopulate(val, "ManagedDisk", &o.ManagedDisk)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &o.Name)
			delete(rawMsg, key)
		case "osType":
				err = unpopulate(val, "OSType", &o.OSType)
			delete(rawMsg, key)
		case "vhd":
				err = unpopulate(val, "Vhd", &o.Vhd)
			delete(rawMsg, key)
		case "writeAcceleratorEnabled":
				err = unpopulate(val, "WriteAcceleratorEnabled", &o.WriteAcceleratorEnabled)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OsProfile.
func (o OsProfile) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "adminUsername", o.AdminUsername)
	populate(objectMap, "computerName", o.ComputerName)
	populate(objectMap, "disablePasswordAuthentication", o.DisablePasswordAuthentication)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OsProfile.
func (o *OsProfile) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "adminUsername":
				err = unpopulate(val, "AdminUsername", &o.AdminUsername)
			delete(rawMsg, key)
		case "computerName":
				err = unpopulate(val, "ComputerName", &o.ComputerName)
			delete(rawMsg, key)
		case "disablePasswordAuthentication":
				err = unpopulate(val, "DisablePasswordAuthentication", &o.DisablePasswordAuthentication)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PlanProperties.
func (p PlanProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "name", p.Name)
	populate(objectMap, "product", p.Product)
	populate(objectMap, "publisher", p.Publisher)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PlanProperties.
func (p *PlanProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
				err = unpopulate(val, "Name", &p.Name)
			delete(rawMsg, key)
		case "product":
				err = unpopulate(val, "Product", &p.Product)
			delete(rawMsg, key)
		case "publisher":
				err = unpopulate(val, "Publisher", &p.Publisher)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PublicKeysProperties.
func (p PublicKeysProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "keyData", p.KeyData)
	populate(objectMap, "path", p.Path)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PublicKeysProperties.
func (p *PublicKeysProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "keyData":
				err = unpopulate(val, "KeyData", &p.KeyData)
			delete(rawMsg, key)
		case "path":
				err = unpopulate(val, "Path", &p.Path)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SecurityProfile.
func (s SecurityProfile) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "encryptionAtHost", s.EncryptionAtHost)
	populate(objectMap, "secureBootEnabled", s.SecureBootEnabled)
	populate(objectMap, "securityType", s.SecurityType)
	populate(objectMap, "virtualTpmEnabled", s.VirtualTpmEnabled)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SecurityProfile.
func (s *SecurityProfile) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "encryptionAtHost":
				err = unpopulate(val, "EncryptionAtHost", &s.EncryptionAtHost)
			delete(rawMsg, key)
		case "secureBootEnabled":
				err = unpopulate(val, "SecureBootEnabled", &s.SecureBootEnabled)
			delete(rawMsg, key)
		case "securityType":
				err = unpopulate(val, "SecurityType", &s.SecurityType)
			delete(rawMsg, key)
		case "virtualTpmEnabled":
				err = unpopulate(val, "VirtualTpmEnabled", &s.VirtualTpmEnabled)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type StorageProfile.
func (s StorageProfile) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dataDisks", s.DataDisks)
	populate(objectMap, "imageReference", s.ImageReference)
	populate(objectMap, "osDisk", s.OSDisk)
	populate(objectMap, "resourceDisk", s.ResourceDisk)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type StorageProfile.
func (s *StorageProfile) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dataDisks":
				err = unpopulate(val, "DataDisks", &s.DataDisks)
			delete(rawMsg, key)
		case "imageReference":
				err = unpopulate(val, "ImageReference", &s.ImageReference)
			delete(rawMsg, key)
		case "osDisk":
				err = unpopulate(val, "OSDisk", &s.OSDisk)
			delete(rawMsg, key)
		case "resourceDisk":
				err = unpopulate(val, "ResourceDisk", &s.ResourceDisk)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type StorageProfileResourceDisk.
func (s StorageProfileResourceDisk) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "size", s.Size)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type StorageProfileResourceDisk.
func (s *StorageProfileResourceDisk) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "size":
				err = unpopulate(val, "Size", &s.Size)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SubnetProperties.
func (s SubnetProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "address", s.Address)
	populate(objectMap, "prefix", s.Prefix)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SubnetProperties.
func (s *SubnetProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "address":
				err = unpopulate(val, "Address", &s.Address)
			delete(rawMsg, key)
		case "prefix":
				err = unpopulate(val, "Prefix", &s.Prefix)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TagsProperties.
func (t TagsProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "name", t.Name)
	populate(objectMap, "value", t.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TagsProperties.
func (t *TagsProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
				err = unpopulate(val, "Name", &t.Name)
			delete(rawMsg, key)
		case "value":
				err = unpopulate(val, "Value", &t.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Versions.
func (v Versions) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "apiVersions", v.APIVersions)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Versions.
func (v *Versions) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "apiVersions":
				err = unpopulate(val, "APIVersions", &v.APIVersions)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VirtualHardDisk.
func (v VirtualHardDisk) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "uri", v.URI)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VirtualHardDisk.
func (v *VirtualHardDisk) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "uri":
				err = unpopulate(val, "URI", &v.URI)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VirtualMachineScaleSet.
func (v VirtualMachineScaleSet) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", v.ID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VirtualMachineScaleSet.
func (v *VirtualMachineScaleSet) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
				err = unpopulate(val, "ID", &v.ID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

func populate(m map[string]any, k string, v any) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else if !reflect.ValueOf(v).IsNil() {
		m[k] = v
	}
}

func unpopulate(data json.RawMessage, fn string, v any) error {
	if data == nil || string(data) == "null" {
		return nil
	}
	if err := json.Unmarshal(data, v); err != nil {
		return fmt.Errorf("struct field %s: %v", fn, err)
	}
	return nil
}

